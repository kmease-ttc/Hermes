You’re thinking about it the right way: **Hermes should be able to connect to every worker the same way**, because the integration pattern is identical. If Google connects but others don’t, it usually means Hermes is doing **special-case parsing** for Google, but the other workers are still using an older/incorrect assumption about how their Bitwarden secret is structured (or what fields are required).

Based on your Bitwarden screenshot, your worker secrets are named like:

* `SEO_Backlinks`
* `SEO_Blog_Writer`
* `SEO_Competitive_Intel`
* `SEO_Content_QA`
* `SEO_Content_Validator`
* `SEO_Google_Connector`
* `SEO_Notifications`
* `SEO_SCHEDULER_API_KEY`
* `SEO_SERP_&_Keyword`
* `SEO_TECHNICAL_CRAWLER_API_KEY`
* `SEO_Vital_Monitor`
  (and a content decay key)

That naming is the clue: some are “API_KEY” style and some are “SEO_<ServiceName>” style — Hermes must handle both consistently.

Here’s how to fix it so **every worker connects the same way** and the dashboard tells you **connection vs correct outputs** cleanly.

---

# Developer Instructions: Standardize Worker Connection via Bitwarden (All Services)

## Goal

For every worker service:

1. Hermes can load its secret from Bitwarden (by secret name)
2. Hermes can derive:

   * `base_url`
   * `api_key`
   * endpoints (health/test/start/status)
3. Hermes can run a **consistent Test Connection**
4. Hermes records a `service_run` immediately:

   * pass/fail
   * actualOutputs
   * metrics
   * jobId (if async)

No per-service special casing.

---

## 1) Create a universal “Worker Secret Contract”

Every worker secret value should be JSON with the same keys.

### Required JSON shape (minimal)

```json
{
  "base_url": "https://<worker-domain>",
  "api_key": "<worker_api_key>"
}
```

### Optional fields (recommended)

```json
{
  "health_path": "/health",
  "test_path": "/api/test",
  "start_path": "/api/run",
  "status_path": "/api/status",
  "timeout_ms": 30000,
  "supports_async": true
}
```

**Important:** Hermes should accept missing optional fields and apply defaults.

---

## 2) Update Hermes BitwardenProvider to always parse worker secrets the same way

### New method (single entry point)

`getWorkerConfig(secretName: string) => WorkerConfig`

Where `WorkerConfig` includes:

* baseUrl
* apiKey
* endpoints (with defaults)
* supportsAsync boolean (default false)

### Parsing rules (must be robust)

Many Bitwarden secrets get saved as:

* raw API key string
* JSON string
* JSON with different key casing

So parsing must:

1. Try JSON parse
2. If parse fails → treat it as `{ api_key: <raw> }`
3. Normalize keys:

   * `base_url`, `baseUrl`, `url` → base_url
   * `api_key`, `apiKey`, `key` → api_key

If base_url is missing after parsing:

* return `configState=needs_config` with reason “base_url missing in secret value”

---

## 3) Update servicesCatalog to reference Bitwarden secret names

In `shared/servicesCatalog.ts`, each worker service needs:

* `integrationType: "remote_worker"`
* `bitwardenSecretName: "<exact Bitwarden name>"`

Examples:

* Backlinks worker: `SEO_Backlinks`
* Blog writer worker: `SEO_Blog_Writer`
* Competitive Intel: `SEO_Competitive_Intel`
* Content QA: `SEO_Content_QA`
* Content Validator: `SEO_Content_Validator`
* Notifications: `SEO_Notifications`
* SERP worker: `SEO_SERP_&_Keyword`
* Technical crawler: `SEO_TECHNICAL_CRAWLER_API_KEY` (rename recommended; see below)
* Vitals monitor: `SEO_Vital_Monitor`
* Google connector: `SEO_Google_Connector`

**Do not assume secret names from slugs.** Use explicit mapping.

---

## 4) Fix the “API_KEY”-named secrets (this is likely why some don’t work)

Your screenshot shows secrets like:

* `SEO_TECHNICAL_CRAWLER_API_KEY`
* `SEO_SCHEDULER_API_KEY`

Those look like they might store **only an API key**, not a JSON blob with a base_url.

If that’s true, Hermes can’t call the worker because it doesn’t know where it lives.

### Two options (pick one and standardize)

**Option A (recommended): Convert those secrets to JSON**
Change the Bitwarden secret value to:

```json
{ "base_url": "https://<crawler-worker>", "api_key": "..." }
```

**Option B: Split into two secrets**

* `SEO_TECHNICAL_CRAWLER_BASE_URL`
* `SEO_TECHNICAL_CRAWLER_API_KEY`

Option A is cleaner and avoids secret sprawl.

---

## 5) Implement a generic Test Connection flow (same for all workers)

### Hermes endpoint

`POST /api/services/:slug/test-connection?site_id=...`

### Generic worker test behavior

1. Load worker config from Bitwarden secret name
2. Call `GET {base_url}{health_path}` with header `X-API-Key: api_key`
3. If 200 → pass “connected”
4. Optionally call `{test_path}` if present (still quick)
5. Write a `service_run` with:

   * status pass/fail
   * actualOutputs: `["worker_health"]` (and `["worker_test"]` if test ran)
   * metrics: `{ httpStatus, latencyMs }`

### Output slugs (standard)

* `worker_health`
* `worker_test`

---

## 6) Stop treating Google as special

If Google is working, copy that pattern:

* It probably has a properly structured secret (base_url + api_key) or it’s in-process

Make every worker follow the exact same contract. Google should not be a one-off.

---

## 7) Improve dashboard so it explains why only Google connects

Add a “Blocking Reason” field when configState isn’t ready:

Examples:

* “Secret not found in Bitwarden”
* “Secret value is missing base_url”
* “Worker health check failed (403)”
* “Worker unreachable (timeout)”

This will immediately reveal what’s wrong.

---

## 8) Immediate likely root cause (based on your screenshot)

Google connects because:

* its Bitwarden secret likely contains both base_url and api_key (or Hermes hardcoded it)

The others don’t connect because:

* their secrets are **API_KEY only** (no base_url)
* or the secret names don’t match the catalog mapping
* or Hermes doesn’t parse the special character name `SEO_SERP_&_Keyword` correctly (URL encoding in lookups)

Fixing the worker secret contract + explicit mapping solves all of these.

---

## What I need from you (smallest next step)

Open one non-Google secret (like `SEO_Backlinks`) and tell me:

* does its value contain a **base_url** or is it **just an API key**?

If it’s just a key, that’s the whole explanation and the fix is to store `{ base_url, api_key }` in that secret (Option A above).
