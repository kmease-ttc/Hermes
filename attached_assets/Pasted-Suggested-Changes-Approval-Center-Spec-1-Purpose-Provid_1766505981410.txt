Suggested Changes Approval Center Spec
	1.	Purpose
Provide a simple, safe, “Accept / Reject” interface inside Hermes that lets you approve system recommendations without needing to understand internal plumbing. Hermes generates structured Change Proposals backed by evidence. You approve them. Hermes applies changes, verifies them, and logs everything.

Primary outcomes:
	•	Reduce manual debugging/config churn (Bitwarden, settings, missing outputs).
	•	Prevent infinite QA/generator loops by forcing deterministic, reviewable actions.
	•	Enable “self-healing” improvements without letting services silently rewrite production.

Non-goals:
	•	Direct service-to-service calls. All coordination remains Hermes-driven.
	•	Fully autonomous merging/deploying without gates (at least initially).

	2.	Core Concepts

2.1 Change Proposal
A Change Proposal is a typed recommendation Hermes can apply (or prepare a patch for) with:
	•	A clear “what/why”
	•	Evidence links (run_id, artifact_id, errors)
	•	An explicit patch / config change plan
	•	A risk rating
	•	Verification steps
	•	Rollback plan

2.2 Proposal Lifecycle (State Machine)
Statuses:
	•	OPEN
	•	IN_REVIEW (optional; when opened)
	•	ACCEPTED (approval recorded)
	•	APPLYING
	•	APPLIED
	•	FAILED
	•	REJECTED
	•	SNOOZED
	•	SUPERSEDED (replaced by a newer proposal)

Rules:
	•	Only Hermes can transition states.
	•	User action causes ACCEPTED / REJECTED / SNOOZED.
	•	APPLYING → APPLIED/FAILED based on verification outcomes.
	•	If a newer proposal makes an older one irrelevant, older becomes SUPERSEDED.

2.3 Proposal Types
Config proposals (low risk):
	•	WEBSITE_SETTING_UPDATE (e.g., base_url missing)
	•	SECRET_FORMAT_FIX (e.g., secret must be JSON envelope)
	•	SERVICE_EXPECTED_OUTPUT_FIX (e.g., missing expected artifact outputs)
	•	SERVICE_REGISTRY_UPDATE (enable/disable service per site)

Operational proposals (medium risk):
	•	RUN_SMOKE_TESTS
	•	RUN_DAILY_DIAGNOSIS
	•	RERUN_FAILED_SERVICE_WITH_PARAMS (with safe params)

Code proposals (higher risk):
	•	CODE_PATCH (apply a unified diff to a specific Replit app/service)
	•	IMPLEMENT_ENDPOINT (e.g., add /capabilities)
	•	SCHEMA_CONFORMANCE_FIX (add schema_version, error model)

Site Change Executor proposals (separate track; future):
	•	SITE_CONTENT_CHANGE (PR-style or CMS write)
	•	SITE_TECH_CHANGE (robots/sitemap/meta updates)

2.4 Risk Model and Safety Gates
Risk levels:
	•	LOW: config-only, non-destructive, reversible
	•	MEDIUM: operational actions, reruns, reversible settings changes
	•	HIGH: code changes, schema changes, deployment actions
	•	CRITICAL: production deployments or anything affecting multiple services/sites

Default gating:
	•	LOW: allow “Accept → Apply” with verification
	•	MEDIUM: allow “Accept → Apply” with verification
	•	HIGH: require “Accept → Apply” plus explicit confirmation in UI (“I understand”)
	•	CRITICAL: disabled by default or requires admin policy flag

2.5 Verification and Rollback
Every ACCEPT must define:
	•	verification_plan: list of checks to run post-apply (smoke tests, connection tests, targeted endpoint test)
	•	rollback_plan: how Hermes will revert if verification fails

Rollback options (Replit-only compatible):
	•	If using Deployments: rollback to last successful deployment
	•	If not: create a “snapshot marker” and provide “manual rollback steps”
	•	Optional: local git commit inside the Repl (no GitHub required) and rollback by reset (recommended)

	3.	UX / UI Requirements

3.1 Left Nav Tab: Suggested Changes
Route: /changes

Layout:
A) Filters and summary
	•	Site selector (all sites / specific site)
	•	Status filter: Open, Snoozed, Applied, Failed, Rejected
	•	Risk filter: Low, Medium, High, Critical
	•	Type filter: Config, Operational, Code
	•	Service filter (optional)
	•	Sort: newest, highest risk, most impactful, blocking first

B) Inbox list (table or cards)
For each proposal:
	•	Title
	•	Site
	•	Service (if applicable)
	•	Type
	•	Risk
	•	Created time
	•	“Blocking?” badge (true/false)
	•	Primary action buttons: Accept, Reject, Snooze

C) Proposal detail drawer/page
When opened, show:
	•	Summary: what Hermes wants to do
	•	Why: diagnosis + evidence
	•	Evidence: linked run_id, artifacts, errors
	•	Change plan: structured steps
	•	Preview: diff/settings/secret envelope preview (as applicable)
	•	Verification plan: what Hermes will run after applying
	•	Rollback plan
	•	Action buttons:
	•	Accept
	•	Reject (requires reason optional)
	•	Snooze (pick duration)
	•	“Accept and Apply” (if policy allows auto-apply)
	•	“Accept Only” (records approval but does not apply until user clicks Apply)

3.2 Per-Service Inspector: Suggested Changes Section
On the service inspector page, add a section:
	•	“Suggested Changes (N)” list scoped to that service + current site
	•	Same Accept/Reject/Snooze behavior
	•	Link to full inbox

3.3 Bulk Actions
Phase 1:
	•	“Accept all LOW risk” for current filter scope
	•	“Snooze all LOW risk” (optional)

Bulk actions must:
	•	show a confirmation modal with count and list summary
	•	create individual acceptance records per proposal
	•	apply sequentially with stop-on-fail (configurable)

3.4 Accessibility/Ergonomics
	•	Keyboard navigation for list and Accept/Reject
	•	Clear status updates (Applying… Verified… Failed…)
	•	Show the most recent logs inline for failures

	4.	Backend Requirements

4.1 Data Model
Tables (or equivalents) to add:

change_proposals
	•	id (uuid)
	•	website_id (uuid)
	•	service_key (string, nullable)
	•	type (enum)
	•	risk_level (enum)
	•	status (enum)
	•	title (string)
	•	description (text)
	•	rationale (jsonb)
	•	evidence (jsonb)  // run_ids, artifact_ids, error codes, urls
	•	change_plan (jsonb) // structured steps
	•	preview (jsonb) // diff/settings/secret envelope preview
	•	verification_plan (jsonb)
	•	rollback_plan (jsonb)
	•	policy_gate (jsonb) // required confirmations, allowed apply modes
	•	created_by (string: system/user)
	•	created_at (timestamp)
	•	updated_at (timestamp)
	•	superseded_by (uuid, nullable)
	•	snoozed_until (timestamp, nullable)
	•	tags (text[])

change_proposal_actions (audit trail per proposal)
	•	id (uuid)
	•	proposal_id (uuid)
	•	actor (string: user_id/email/system)
	•	action (enum: OPENED, ACCEPTED, REJECTED, SNOOZED, APPLY_STARTED, APPLY_SUCCEEDED, APPLY_FAILED, COMMENTED)
	•	reason (text, nullable)
	•	metadata (jsonb) // applied patch ref, settings changes, test run ids
	•	created_at (timestamp)

apply_jobs (optional, if async apply)
	•	id (uuid)
	•	proposal_id (uuid)
	•	status (queued/running/succeeded/failed)
	•	logs_ref (string or jsonb)
	•	started_at, ended_at
	•	verification_results (jsonb)

4.2 API Endpoints (Hermes Core)
Change proposals:
	•	GET /api/changes
query params: website_id, status, risk, type, service_key, q, sort
	•	GET /api/changes/:id
	•	POST /api/changes/:id/accept
body: { apply_now?: boolean, confirmation_flags?: {…} }
	•	POST /api/changes/:id/reject
body: { reason?: string }
	•	POST /api/changes/:id/snooze
body: { until: timestamp }
	•	POST /api/changes/bulk
body: { ids: [], action: “accept”|“snooze”|“reject”, apply_now?: boolean }

Apply engine:
	•	POST /api/changes/:id/apply
body: { confirmation_flags?: {…} }
returns: { apply_job_id } or synchronous result

Evidence linking:
	•	GET /api/runs/:run_id
	•	GET /api/artifacts/:artifact_id
(If these already exist, reuse.)

4.3 Proposal Generation (How proposals are created)
Sources:
	•	Orchestrator readiness checks (missing required inputs/outputs)
	•	Service health and error parsing (JSON invalid, auth failures, rate limits)
	•	Schema validation (missing schema_version, invalid artifact types)
	•	Workflow loop detectors (QA/generator repeated failures)
	•	“Not built yet” detection (blocked services)
	•	Manual user request (button: “Propose Fix”)

Minimum generator rules (Phase 1):
	•	If service status is Needs Config and missing_inputs are known → create WEBSITE_SETTING_UPDATE or SECRET_FORMAT_FIX proposal.
	•	If service returns parse error like “secret JSON invalid” → create SECRET_FORMAT_FIX with exact expected envelope preview.
	•	If Orchestrator says “Missing N expected outputs” → create SERVICE_EXPECTED_OUTPUT_FIX proposal with required artifact types and steps.
	•	If a loop is detected (same content item failing QA > max_rewrites) → create CODE_PATCH (patch-based rewrite support) or POLICY_CHANGE proposal.

Deduping:
	•	Proposals should have a stable fingerprint hash:
hash = website_id + service_key + type + normalized_target
	•	If an OPEN proposal with same fingerprint exists, update it rather than creating a new one.

4.4 Apply Handlers (How Hermes applies a proposal)
Each proposal type maps to an apply handler:
	•	WEBSITE_SETTING_UPDATE: update Website Registry row(s)
	•	SECRET_FORMAT_FIX: write updated secret value to Bitwarden via your existing Bitwarden integration
	•	SERVICE_EXPECTED_OUTPUT_FIX: typically a code/config proposal; if purely config, apply; otherwise create CODE_PATCH
	•	RUN_SMOKE_TESTS / RUN_DAILY_DIAGNOSIS: call orchestrator workflow endpoints
	•	CODE_PATCH: apply diff to the target Replit app (see below)

4.5 Code Patch Application Without GitHub
Define a standardized “patch package” stored in preview/change_plan:
	•	target_app: string (replit app name or base_url)
	•	files: [{ path, original_hash, patch_unified_diff }]
	•	commands_after_apply: [“npm test”, “npm run lint”, “node scripts/smoke.js”] (optional)
	•	success_criteria: list of checks (e.g., /health, /capabilities, expected artifacts produced)
	•	rollback_instructions: snapshot/deployment rollback

Apply mechanisms (choose one for Phase 1):
A) Manual apply (safest first)
	•	Hermes displays patch in UI and offers “Copy patch”
	•	Developer applies in Replit
	•	Hermes then runs verification steps and marks APPLIED/FAILED

B) Semi-automated apply (recommended next)
	•	Implement a small internal “Patch Executor” service that:
	•	receives patch package
	•	applies to a checked-out workspace (or via Replit API if available in your environment)
	•	runs commands
	•	returns logs + results
Note: If you don’t have an API for patching Replit files, keep Phase 1 manual and still get 80% UX benefit.

4.6 Verification
Verification plan types:
	•	connection_tests: run existing “Test Connections”
	•	smoke_tests: run existing “Run Smoke Tests”
	•	targeted_endpoint_tests: call service endpoints (/health, /capabilities, /run sample)
	•	artifact_presence_checks: assert required artifact types exist for run_id

Verification results stored on proposal:
	•	verification_results: pass/fail per check + logs refs

4.7 Permissions / Roles
Minimum:
	•	Only authenticated admins can Accept/Reject/Apply
	•	Read-only users can view proposals and evidence

Optional:
	•	Per-site permissions
	•	Separate “Apply code changes” permission

	5.	Acceptance Criteria

Phase 1 (must-have)
	•	Suggested Changes inbox exists and lists proposals by site/service/type/risk.
	•	Per-proposal detail shows evidence and a preview of what will change.
	•	Accept/Reject/Snooze works and records an audit entry.
	•	Applying config proposals updates settings/secrets and then runs verification.
	•	On verification failure, proposal becomes FAILED with logs visible.
	•	Proposals dedupe (no spam duplicates for same issue).

Phase 2 (should-have)
	•	Bulk accept LOW risk proposals with sequential apply + stop-on-fail.
	•	Per-service inspector shows scoped proposals.
	•	Loop detection generates a proposal when QA/generator repeats beyond cap.

Phase 3 (later)
	•	Code patch proposals can be applied semi-automatically and gated by confirmations.
	•	“Promote to deployment” gate (if using Replit Deployments).
	•	Auto-suggested improvements become KBase drafts.

Developer Prompt for Replit (Implementation Instructions)

Build the “Suggested Changes” feature inside Hermes (SEO Orchestrator) as a first-class approval center for recommendations.

Goals
	•	Add a left-nav tab “Suggested Changes” that shows Change Proposals Hermes has generated (config fixes, operational actions, code patch proposals).
	•	Provide Accept/Reject/Snooze actions.
	•	For applicable proposals, allow Apply (with verification) and show results/logs.
	•	Maintain a full audit trail of all actions and outcomes.

Work Scope
	1.	Database

	•	Add tables: change_proposals, change_proposal_actions, apply_jobs (optional)
	•	Use enums for status/type/risk.
	•	Include fields for evidence, preview, change_plan, verification_plan, rollback_plan (jsonb).
	•	Add dedupe fingerprint hash index.

	2.	Backend API (Hermes Core)
Implement endpoints:

	•	GET /api/changes (filters: website_id/status/risk/type/service_key/sort/search)
	•	GET /api/changes/:id
	•	POST /api/changes/:id/accept { apply_now?, confirmation_flags? }
	•	POST /api/changes/:id/reject { reason? }
	•	POST /api/changes/:id/snooze { until }
	•	POST /api/changes/:id/apply { confirmation_flags? }
	•	POST /api/changes/bulk { ids, action, apply_now? }

	3.	UI

	•	Add left nav item: Suggested Changes
	•	Page layout:
	•	Filters (site/status/risk/type/service)
	•	List of proposals with quick actions (Accept/Reject/Snooze)
	•	Detail drawer/panel showing:
	•	what/why
	•	evidence links to run/artifacts
	•	preview (settings diff, secret envelope preview, or patch diff)
	•	verification plan + rollback plan
	•	Apply button (only if allowed)
	•	Add per-service inspector section: Suggested Changes (scoped list + link to inbox)

	4.	Proposal Generation (Phase 1)
Create a proposal generator module that runs after:

	•	Test Connections
	•	Run Smoke Tests
	•	Orchestrator readiness checks

Rules:
	•	If a service error indicates “secret JSON invalid” or “secret not JSON format”, generate SECRET_FORMAT_FIX proposal with the expected JSON envelope preview and the exact Bitwarden key name.
	•	If a service shows “No base URL configured” or missing website settings, generate WEBSITE_SETTING_UPDATE proposal.
	•	If orchestrator/audit show “Missing N expected outputs,” generate SERVICE_EXPECTED_OUTPUT_FIX proposal with required artifact types and recommended changes.

Implement dedupe:
	•	fingerprint = hash(website_id + service_key + type + normalized_target)
	•	If OPEN proposal exists with same fingerprint, update it instead of creating new.

	5.	Apply Handlers (Phase 1)
Implement apply handlers for:

	•	WEBSITE_SETTING_UPDATE: update Website Registry settings for website_id
	•	SECRET_FORMAT_FIX: update Bitwarden secret value using existing Bitwarden integration
	•	RUN_SMOKE_TESTS / RUN_DAILY_DIAGNOSIS: trigger existing workflows

After applying, run verification:
	•	Run Test Connections and/or Smoke Tests depending on proposal.verification_plan
	•	Store results and logs, set proposal to APPLIED or FAILED

	6.	Safety Gates

	•	Implement risk gating:
	•	LOW/MEDIUM: allow apply
	•	HIGH: require confirmation_flags checkbox in UI and API
	•	CRITICAL: do not allow apply unless a policy flag is enabled (stub for now)
	•	Require admin role for Accept/Reject/Apply.

	7.	Audit Trail
Every action (open, accept, reject, snooze, apply start, apply success/fail) must create a change_proposal_actions row.
Expose actions in proposal detail view.
	8.	Acceptance Tests (minimum)

	•	Create sample proposals and verify list filters work.
	•	Accept/Reject/Snooze transitions update status and write audit rows.
	•	Applying a SECRET_FORMAT_FIX updates secret, then reruns verification and marks APPLIED.
	•	Applying with forced failure marks FAILED and shows logs.
	•	Deduping prevents duplicates for same fingerprint.

Deliverables
	•	Database migrations
	•	API endpoints + server-side validation
	•	UI pages/components
	•	Proposal generator module
	•	Apply handlers + verification runner
	•	Basic tests or a runnable script to create seed proposals for manual QA

Notes
	•	Do not introduce service-to-service calls. All coordination stays inside Hermes.
	•	Keep proposal payloads structured and auditable. Always include evidence references (run_id, artifact_id, error codes).
	•	Keep Phase 1 focused on config + operational proposals; code patch proposals can exist as “manual apply” previews (no auto-apply required yet).