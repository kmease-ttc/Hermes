Nice — with the worker contract solid, the only remaining work is **wiring the outputs into Hermes so they actually show up in the product UI** (and not just “the worker ran”).

Here are the exact instructions to make that happen, in the same pattern that you used for Google.

## 1) Confirm Hermes recognizes SEO_KBASE as a worker connector

In Hermes integration registry (DB row / config), ensure for `seo_kbase`:

* `mode = "worker"`
* connection secret points to the Bitwarden JSON for this worker
* `expected_outputs` matches what the worker returns (at least one output key, even if it’s a single blob)

If Hermes still thinks it’s oauth/native, it’ll run the wrong path and the UI will drift.

## 2) Define the canonical “outputs” for SEO_KBASE

Pick the smallest stable set so schema validation and UI mapping stay consistent. Example:

* `kbase_articles` (array)
* `kbase_gaps` (array)
* `kbase_recommendations` (array)
* `kbase_summary` (string)

Whatever you choose, make sure `/api/capabilities.outputs[]` lists them and `/api/run` returns them under `data`.

## 3) Make Hermes persist the run + normalized outputs

When Hermes calls `POST {base_url}/run`, it must:

1. Create an `integration_runs` record:

* integration_id = seo_kbase
* site_id
* status
* raw_payload (worker response)
* received_outputs/missing_outputs

2. Normalize into Hermes tables so the UI can read it without custom parsing:

* Either:

  * `site_findings` (recommended): one row per “finding”
  * or `site_kbase` / `kbase_results` (if you want a dedicated table)

A simple normalization that works well:

**Table: `site_findings`**

* site_id
* source_integration = "seo_kbase"
* category = "kbase"
* severity (info/low/med/high)
* title
* description
* recommendation
* evidence_json (optional)
* created_at
* run_id

Then the UI just queries findings by site.

## 4) Wire it into the right tabs (minimal v1)

Don’t overthink it—just make it visible everywhere you’d expect “knowledge base guidance” to appear.

### Dashboard

* Add a “Knowledge Base” card:

  * count of new findings
  * last run timestamp
  * top 1–3 recommendation titles

### Analysis tab

* Add a section: “Knowledge Base Insights”

  * list of the findings
  * filter by severity/category

### Suggested Changes tab

* Pull KBASE findings in as “Suggested Changes”

  * these are basically the recommended actions
  * tie each suggestion back to `run_id` and `source_integration`

### Integrations tab

* After run completes:

  * update `last_run_at`, `last_status`, `missing_outputs`
  * show “0 missing” if schema validated

## 5) Cache invalidation (so you don’t see stale UI)

After a successful `seo_kbase` run, invalidate/re-fetch:

* dashboard query
* findings query
* suggested changes query
* integrations list + modal

If you’re using React Query/SWR, explicitly invalidate those keys on completion.

## 6) Add traceability links everywhere

Every surfaced insight should show:

* “Source: SEO_KBASE · <timestamp>”
* “Run: <run_id> (view diagnostics)”

This is what prevents screenshot debugging later.

---

### Implementation prompt (paste into Hermes agent)

Wire SEO_KBASE worker outputs into Hermes UI tabs.

Context:
SEO_KBASE worker is gold-standard compliant. All endpoints work:

* /api/health, /api/smoke-test, /api/capabilities, /api/run
  Auth uses TRAFFIC_DOCTOR_API_KEY and returns JSON-only.

Goal:
When Hermes runs SEO_KBASE (manual or scheduled), persist the results and surface them in Dashboard, Analysis, Suggested Changes, and Integrations list/modal.

Steps:

1. Integration definition

* Ensure `seo_kbase` is mode="worker"
* Ensure it references the correct Bitwarden connection secret
* Ensure expected_outputs is aligned with worker /api/capabilities.outputs

2. Worker run

* Implement or confirm Hermes calls: POST {base_url}/run with { site_id, domain, requested_outputs }
* Include headers: x-api-key + Authorization Bearer + X-Request-Id

3. Persistence

* Create integration_runs row for each run:

  * integration_id=seo_kbase, site_id, status, started_at, completed_at, raw_payload, received_outputs, missing_outputs, diagnostics_run_id
* Normalize results into a shared table the UI already understands:

  * Prefer site_findings:

    * site_id
    * source_integration="seo_kbase"
    * category="kbase"
    * severity
    * title
    * description
    * recommendation
    * evidence_json
    * run_id
* If worker returns a blob, map it into multiple findings rows.

4. UI wiring

* Dashboard: add “Knowledge Base” card showing:

  * number of findings from seo_kbase
  * last run timestamp
  * top 3 recommendation titles
* Analysis tab: add a “Knowledge Base Insights” section listing findings with filters.
* Suggested Changes: ingest seo_kbase findings into suggested changes list (source labeled).
* Integrations list/modal: update missing count, last status, last run, and show latest run summary from persisted snapshot.

5. Cache invalidation
   After seo_kbase run completes, invalidate/refetch:

* dashboard
* findings/analysis
* suggested changes
* integrations list + details

6. Traceability
   Every UI item should include:

* source integration (SEO_KBASE)
* run timestamp
* link to run diagnostics (diagnostics_run_id)

Acceptance criteria:

* Running SEO_KBASE updates the Integrations row to 0 missing (if outputs present)
* Dashboard/Analysis/Suggested Changes show fresh KBASE findings immediately without refresh
* Each finding links back to the run that produced it

If you tell me what you want the SEO_KBASE worker to *actually return* (titles only vs full markdown articles vs “gaps + recommended pages”), I can tighten the output schema so it’s future-proof and fits cleanly into Suggested Changes.
