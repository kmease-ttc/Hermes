Step 4 is where this turns from “cool preview” into a real product:
plans → payment → subscription → domain connect.

I’ll lay out the next phase, then give concrete dev instructions you can hand off.

STEP 4 – Plans, Stripe, Subscription, and Domain Connect (MVP)

Goal
	•	Let a logged-in user pick Starter/Pro on the preview page.
	•	Take payment via Stripe Checkout.
	•	Store subscription in your DB.
	•	Move site to live_pending_dns and show DNS instructions.

We’ll still not turn on any SEO automation yet – that’s next.
	1.	Add Subscription model

In /app DB schema, add:

Subscription
	•	id (PK)
	•	user_id (FK → User)
	•	site_id (FK → Site)
	•	plan (string: ‘starter’ | ‘pro’)
	•	status (string: ‘pending’ | ‘active’ | ‘canceled’)
	•	stripe_customer_id (string, nullable)
	•	stripe_subscription_id (string, nullable)
	•	stripe_checkout_session_id (string, nullable)
	•	created_at (datetime)
	•	updated_at (datetime)

	2.	Configure Stripe

In /app:

Env vars:
	•	STRIPE_SECRET_KEY
	•	STRIPE_PRICE_STARTER (price id for $149/mo)
	•	STRIPE_PRICE_PRO (price id for $299/mo)
	•	APP_PUBLIC_URL (for redirect URLs)
	•	STRIPE_WEBHOOK_SECRET

Basic Stripe setup file (e.g. src/stripe.ts) that exports a configured Stripe client.
	3.	Plan selection API

On the backend:

Endpoint: POST /api/sites/:id/checkout

Body:

{
  "plan": "starter" | "pro"
}

Auth: requires session; only site owner can call it.

Logic:
	1.	Verify req.user exists.
	2.	Load Site by id and ensure site.user_id === req.user.id.
	3.	Ensure plan is valid.
	4.	Create or reuse Subscription row:
	•	If there’s already a non-canceled subscription for this site, return an error or redirect.
	•	Otherwise insert:
	•	user_id = req.user.id
	•	site_id = site.id
	•	plan = plan
	•	status = ‘pending’
	5.	Create Stripe Checkout session:

const session = await stripe.checkout.sessions.create({
  mode: 'subscription',
  customer_email: user.email,
  line_items: [
    {
      price: plan === 'starter'
        ? process.env.STRIPE_PRICE_STARTER
        : process.env.STRIPE_PRICE_PRO,
      quantity: 1,
    },
  ],
  success_url: `${APP_PUBLIC_URL}/sites/${site.id}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
  cancel_url: `${APP_PUBLIC_URL}/sites/${site.id}/preview`,
  metadata: {
    site_id: site.id.toString(),
    user_id: user.id.toString(),
    plan,
  },
});


	6.	Save stripe_checkout_session_id = session.id on the Subscription row.
	7.	Return { url: session.url }.

Frontend behavior on /sites/:id/preview:
	•	When user clicks “Starter” or “Pro”, call POST /api/sites/:id/checkout.
	•	On success: window.location.href = response.url to send them to Stripe Checkout.

	4.	Stripe webhooks (activate subscription)

Create endpoint: POST /webhooks/stripe
	•	Use Stripe’s webhook signature verification with STRIPE_WEBHOOK_SECRET.
	•	Handle at least these events:
	•	checkout.session.completed
	•	(Optionally customer.subscription.updated / canceled later)

For checkout.session.completed:
	1.	Extract session.id, session.subscription, session.customer.
	2.	Find Subscription row by stripe_checkout_session_id = session.id.
	3.	If found:
	•	Update:
	•	stripe_customer_id = session.customer
	•	stripe_subscription_id = session.subscription
	•	status = 'active'
	4.	Update Site:
	•	site.status = 'live_pending_dns'

Respond with 200.
	5.	Payment success page

Route: /sites/:id/payment-success
	•	Behind auth.
	•	Calls GET /api/sites/:id to confirm status === 'live_pending_dns'.
	•	If not active yet (webhook delay), show “We’re finishing your setup, refresh in a minute.”
	•	If live_pending_dns, show “Your subscription is active. Next step: connect your domain.”

	6.	DNS / domain connect flow

Add fields to Site:
	•	domain (string, nullable)
	•	dns_verified_at (datetime, nullable)

Backend endpoints:
	1.	POST /api/sites/:id/domain

Body:

{
  "domain": "example.com"
}

Logic:
	•	Require auth + ownership.
	•	Save site.domain = domain.
	•	Set status (stay live_pending_dns).
	•	Enqueue a verify_domain job (type verify_domain, payload { siteId }).

	2.	Worker: handle verify_domain jobs (v0 can be manual)

For v0 you can stub this:
	•	verify_domain simply:
	•	Logs “Verify DNS for site X, domain Y”.
	•	Sets dns_verified_at = now().
	•	Enqueues a go_live job.

(You can manually trigger this in dev until you wire real DNS checks.)
	3.	go_live job in worker

Job type: go_live with payload { siteId }.

Steps:
	•	Load Site by id.
	•	Call your RedBullit/Replit deployment API to:
	•	Promote from preview → production under site.domain.
	•	Get final live_url (e.g. https://example.com).
	•	Update Site:
	•	live_url = ...
	•	status = 'live'

Log: “Site X is now live at live_url”.

Frontend: “Connect domain” page /sites/:id/domain
	•	Only accessible if site.status is live_pending_dns or live.
	•	Shows:
	•	Input for domain.
	•	DNS instructions (A/CNAME records depending on how you’re deploying).
	•	After they enter domain and submit POST /api/sites/:id/domain, show a “We’re verifying your domain; this can take a few minutes” state.
	•	Once status changes to live, show a confirmation with a “View my live site” button linking to live_url.

	7.	Acceptance criteria for this step

	•	On preview page, user can click a plan → gets redirected to Stripe Checkout.
	•	After successful payment:
	•	Stripe webhook marks Subscription as active.
	•	Site status becomes live_pending_dns.
	•	User visiting /sites/:id/payment-success after payment sees domain connect instructions.
	•	User can submit a domain and (with stubbed verify/go_live):
	•	Worker runs verify_domain → go_live.
	•	Site.status becomes live.
	•	Site.live_url is set.

Once this is in place, the next step after this will be:
	•	Step 5 – automation skeleton:
	•	Add Keyword + Metric + Action tables.
	•	Implement daily_maintenance and weekly_wave jobs (even with stub data).
	•	Build the first version of the dashboard + daily email.

But for now, the very next dev work is:
“Plan selection → Stripe Checkout → Subscription → live_pending_dns → domain connect + go_live job.”