You are a senior full-stack engineer working inside this Replit project.

Goal
Take the mission execution/completion system that we implemented for Socrates (durable storage of mission executions, server-side cooldown enforcement, Missions State endpoint, and UI showing Next Actions + Recently Completed) and roll it out comprehensively to:

1. The Mission Control Dashboard (home page)
2. EVERY crew/agent page (all agents in the left rail)

This must be done in a way that prevents future drift: no one-off implementations per agent.

Non-negotiables

* Do NOT “copy/paste” mission logic into each agent page manually.
* Implement ONE shared mission system (server + client) and have all pages consume it.
* Confirm, with an explicit inventory, that EVERY agent is covered (no missing Scotty/Lookout/etc.).
* Recently Completed must show ONE most recent completed mission per crew + site.
* Next Actions must exclude missions in cooldown (server-side enforced).
* Fix it must call a single mission execution endpoint that records completion on success.
* The UI must match the Speedster/Socrates Mission widget styling (yellow/gold accent, one consolidated widget).

Phase 0 — Inventory (must do first)

1. Enumerate all agents/crews from the canonical source (crew registry / nav config).

* Print the list in the final response.
* This list is the contract for coverage.

2. Enumerate all places Missions appear:

* Mission Control Dashboard (home)
* Each crew page using CrewDashboardShell
* Any other mission panels (if present)

Phase 1 — Server: make Socrates mission engine truly generic
3) Identify the existing Socrates mission completion implementation:

* DB table for mission executions (or audit log equivalent)
* Endpoint(s) used:

  * POST /api/missions/execute
  * GET /api/missions/state
* Cooldown logic (default 24h, configurable)

4. Generalize it so it supports ALL crews

* Mission definitions must be data-driven (registry), not hardcoded in Socrates routes.
  Create/confirm a shared mission registry, e.g.:
* shared/missions/missionRegistry.ts (or server/missions/registry.ts)
  Each mission definition must include:
* crewId
* missionId
* title
* description
* impact/effort (optional)
* action handler (server-side execute function)
* cooldown policy (default to 24h)

5. Standardize execution flow

* POST /api/missions/execute must:

  * validate siteId + crewId + missionId
  * look up mission definition
  * enforce cooldown (409 if in cooldown)
  * run the mission handler
  * determine success only if verified (crew-specific verification allowed)
  * persist a mission execution row:

    * siteId, crewId, missionId, status, summary, metadata, completedAt
  * return:

    * execution record + any updated counts needed by UI

6. Missions state endpoint (single source of truth)

* GET /api/missions/state?siteId=&crewId=
  Must return:
* nextActions: mission list eligible to run (excluding cooldown’d)
* lastCompleted: latest successful execution (single item)
* status summary (needs attention / doing okay) + next line
  This endpoint should compute Next Actions for every crew consistently.

7. Add a dashboard endpoint

* GET /api/missions/dashboard?siteId=
  Returns:
* aggregated status across all crews
* top next actions across all crews (prioritized)
* lastCompletedAcrossAll (optional, but at least provide a list or top 1)
  This powers Mission Control Dashboard.

Phase 2 — Client: one shared Missions widget everywhere
8) Create/confirm a shared UI component used everywhere:

* client/src/components/missions/MissionsWidget.tsx (or existing)
  It must render:
* Header: “Missions” or “Mission Overview” + status pill + Fix Everything button
* Next line: “Next: …”
* NEXT ACTIONS list (top 2–3)
* RECENTLY COMPLETED section (single item)
* Must use the same yellow/gold accent style as Speedster

9. Wire ALL crew pages via CrewDashboardShell

* CrewDashboardShell must render MissionsWidget and pass crewId + siteId
* Crew pages must not implement their own mission widget

10. Wire Mission Control Dashboard

* Replace the existing separate Mission Status + Missions cards with the same consolidated MissionsWidget (dashboard mode)
* Keep the Blockers section untouched.
* The dashboard MissionsWidget should use:

  * /api/missions/dashboard
  * and still show Fix Everything
  * and show aggregated Next Actions across crews
  * and a Recently Completed (either last across all or a short list; if only one, use “Recently Completed” with the latest)

Phase 3 — Fix Everything on Mission Control
11) Ensure Fix Everything uses the new execution pipeline

* When clicked on Mission Control:

  * fetch dashboard nextActions
  * execute them sequentially (or queued) via POST /api/missions/execute
  * update progress UI
  * after completion: refresh dashboard endpoint and UI

Phase 4 — Ensure EVERY agent is covered (no misses)
12) For each crewId from Phase 0 inventory:

* Confirm:

  * Its crew page shows the MissionsWidget
  * /api/missions/state returns a non-error payload
  * Fix it works (even if it returns “No data yet”, it should be a valid response)
* Add a dev-only test page or script that iterates all crews and logs:

  * state endpoint status code
  * nextActions count
  * lastCompleted presence

Phase 5 — Verification checklist (required before concluding)

* Mission Control Dashboard:

  * shows consolidated missions widget (yellow/gold)
  * Fix Everything works
  * Blockers unchanged
  * Recently Completed visible when at least one mission has run
* Crew pages (spot check at least):

  * Speedster
  * Socrates
  * Scotty
  * Sentinel
  * Popular
  * Hemingway
    All show:
  * Next Actions
  * Recently Completed (single)
  * Fix it uses POST /api/missions/execute and respects cooldown

Deliverables (must include in final response)

* List of all crews/agents found in inventory (this proves you covered all)
* File paths changed
* Endpoints implemented/updated
* Confirmation that Mission Control + every crew page uses the shared MissionsWidget
* Notes on how cooldown + persistence are enforced server-side
