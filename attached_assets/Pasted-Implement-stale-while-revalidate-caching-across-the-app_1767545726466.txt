Implement “stale-while-revalidate” caching across the app so pages never go blank while loading. Always show last-known values immediately, then refresh in the background and update when new data arrives.

Problem

* Pages/widgets render blank/skeleton states on navigation, then populate later.
* This feels like “no cache” or “cache not being used,” even though we already have prior values.
* Requirement: never blank out values during refetch; show the previous value (“stale”) instantly, then update.

Target behavior

* On first visit: show skeleton (no prior data).
* On subsequent visits/navigation:

  * show cached/last-known data immediately
  * start background refetch
  * update UI when new data arrives
  * if refetch fails, keep stale data visible and show a small “stale” indicator + retry button (no dead ends).

Architecture choice (recommended)
Use client-side SWR semantics (stale-while-revalidate) + persistence:

* React Query (TanStack Query) OR SWR
* Persist query cache to localStorage/IndexedDB so it survives reloads
* Warm the cache via prefetch on route transitions

Implementation plan

1. Standardize data fetching on TanStack Query (preferred)
   If not already using it everywhere, migrate pages incrementally:

* Dashboard
* Mission Control
* Crew pages (Popular/Lookout/etc.)
* Settings / Websites

Query keys must be stable:

* ['site', siteId, 'dashboard']
* ['site', siteId, 'crew-status']
* ['site', siteId, 'crew', crewId, 'detail']
* ['site', siteId, 'mission-control']
* ['site', siteId, 'learnings', crewId]

2. Never clear data on refetch
   For each query:

* keepPreviousData: true (critical)
* staleTime: e.g. 60s–300s depending on endpoint
* gcTime (cacheTime): e.g. 30–120 minutes
* refetchOnWindowFocus: true (optional)
* retry: 1–2, with backoff

Result:

* when parameters change or navigation occurs, you keep rendering the previous data while fetching the new.

3. Persist the cache (so refresh doesn’t blank the page)
   Add TanStack Query persistence (localStorage or IndexedDB):

* If localStorage is enough: persistQueryClient to localStorage
* If large payloads: use IndexedDB (better for bigger caches)

Persist only safe, non-sensitive values:

* scores, KPIs, missions, learnings summaries
* avoid persisting raw OAuth tokens or secrets (never in client anyway)

4. Prefetch on navigation (pre-caching)
   When a user:

* selects a site
* hovers a crew card
* opens Mission Control
  prefetch the next likely routes:

Examples:

* On dashboard load:
  prefetch ['site', siteId, 'crew-status']
  prefetch ['site', siteId, 'mission-control']
  prefetch ['site', siteId, 'dashboard-overview']

* On crew card hover (e.g., Popular):
  prefetch ['site', siteId, 'crew', 'popular', 'detail']
  prefetch ['site', siteId, 'learnings', 'popular']

This makes crew pages feel instant.

5. Add a subtle “Updating…” indicator instead of blank states
   Replace full skeletons on subsequent loads with:

* a small spinner in the corner of the widget/card
* “Updated X minutes ago” timestamp
* “Stale” badge if data older than threshold

Rules:

* If data exists: never show a large blank skeleton
* If no data exists: show skeleton or an actionable empty state

6. API-side caching (optional but helpful)
   Add HTTP caching headers for GET endpoints:

* Cache-Control: private, max-age=0, stale-while-revalidate=60 (or similar)
* ETag or Last-Modified
  So the browser and edge can help too.
  But primary UX fix is client cache.

7. Acceptance criteria

* Navigating between Dashboard → Crew → Mission Control never blanks values that were previously loaded.
* Values render immediately from cache; background fetch updates them.
* If fetch fails, stale values remain and UI shows a small error badge + Retry (no dead ends).
* First-time visit still shows skeleton only until first data is loaded.

Deliverable

* One PR that:

  1. standardizes key pages on TanStack Query with keepPreviousData
  2. adds query cache persistence
  3. adds route/hover prefetching for crew pages + mission control
  4. replaces “blank while loading” states with “stale while revalidating” UI patterns
