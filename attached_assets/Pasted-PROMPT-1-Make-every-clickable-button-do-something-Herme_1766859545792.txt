PROMPT 1 — “Make every clickable button do something (Hermes)”

You are working inside my Replit project (“Hermes”). Goal: eliminate dead/placeholder UI. Every clickable element must either (a) navigate to a real landing page, (b) open a real modal/drawer with functional content, or (c) trigger a real API action and show a success/error result. No click should ever do nothing.

Scope
	•	Frontend: scan all pages/components for clickable elements:
	•	button, a, Link, icon buttons, cards with onClick, list rows, table actions, menu items, breadcrumbs, “View details”, “Run”, “Refresh”, “Compare”, “Export”, “Settings”, “Help”, “Learn more”, etc.
	•	Backend: verify that any action buttons call an existing endpoint and handle errors.
	•	Services: Hermes has integrations for GA4, Search Console, SERP, Technical SEO, Performance, Competitive Intel, Decay Monitor, Knowledge Base, Domain Authority, Blog Writer, Mission Control Orchestrator, Audit Log, Notifications.

Acceptance criteria
	1.	Click audit:
	•	Produce /docs/ui-click-map.json containing:
	•	element_id (stable), visible label, route/page it appears on, intended behavior type (NAVIGATE | MODAL | ACTION), destination route or endpoint, and current status (OK | FIXED | TODO)
	•	Add stable selectors to every clickable element:
	•	data-testid=“btn--” (or link-/card-/menu- prefixes)
	2.	Routing completeness:
	•	If a clickable element navigates: its destination route must exist, render, and have a meaningful header, description, and either data, empty-state, or “coming soon with why + next step”.
	•	If the route depends on a service that isn’t configured, show a proper empty state and a “Configure” CTA that navigates to Integrations/Settings.
	3.	Action completeness:
	•	If a clickable triggers an action: implement the handler, call the API, show loading state, show toast/inline result, and write an audit log entry.
	•	On error: show a human-readable error state and do not silently fail.
	4.	UX hygiene:
	•	Disable buttons that truly cannot run (missing required integration), with tooltip explaining what’s missing and a link to fix it.
	•	Remove or replace any placeholder href=”#” or noop onClick.
	5.	No regressions:
	•	App builds and runs.
	•	Navigation works for all routes.
	•	Lint/typecheck (if present) passes.

Implementation plan (do all steps)
A) Inventory
	•	Create a small script or runtime scan that lists clickable elements + route context (best effort).
	•	Also do a manual static scan of /src for patterns: onClick=, <button, <Link, href=, IconButton, MenuItem, Card onClick.
	•	Generate /docs/ui-click-map.json from this.

B) Fix dead clicks
	•	For each TODO:
	•	Decide behavior:
	•	NAVIGATE: create route + page shell + empty state (if needed)
	•	MODAL: implement modal with at minimum title, description, and at least one real action or navigation
	•	ACTION: implement API call + result surface + audit log entry
	•	Add missing routes:
	•	/integrations (overview + per-service detail)
	•	/integrations/ga4, /integrations/gsc, /integrations/serp, /integrations/technical, /integrations/performance, /integrations/competitive, /integrations/decay, /integrations/kbase, /integrations/authority, /integrations/blog, /integrations/orchestrator, /integrations/audit, /integrations/notifications
	•	/runs (orchestrator run history)
	•	/runs/:id (run detail)
	•	/audit (audit log viewer)
	•	/reports (optional landing if there are report buttons)
	•	/help (basic help + links)
(Adjust paths to match current router conventions; keep consistency.)

C) Standardize behaviors
	•	Create shared components:
	•	

<EmptyState title description ctaLabel ctaTo />



	•	

<ActionButton endpoint method payload onSuccess onError />



	•	

<ResultToast />



	•	Ensure every action logs to audit log (server-side or client-side call to audit endpoint).

D) Wire buttons to real destinations
	•	Replace placeholder handlers with real navigation, modal open, or API call.

Deliverables
	•	/docs/ui-click-map.json updated with all items OK or FIXED (no TODO left unless it’s truly out of scope; if out of scope, mark BLOCKED with reason).
	•	A PR-style summary in /docs/ui-click-map.md describing what routes were added and what actions were implemented.
	•	All clickable elements have data-testid.

Start now: scan the codebase, generate the click map, then fix everything.

PROMPT 2 — “Add a Playwright UI tester that clicks everything”

You are working inside the Hermes Replit project. Goal: add an automated UI test runner that verifies no dead clicks and that every clickable element either navigates to a real page, opens a modal, or triggers an action that produces a visible result. Use Playwright.

Requirements
	•	Use Playwright test runner (Node) OR Playwright Python if the project is already Python-first. Choose the path that fits the repo; do not add both.
	•	Tests must run headless by default and be runnable locally and in Replit.
	•	Add a single command to run UI tests:
	•	npm run test:ui  OR  python -m pytest -k ui
	•	Output:
	•	HTML report + trace on failure
	•	Screenshots on failure
	•	Use stable selectors:
	•	data-testid everywhere for clickable elements
	•	Do not require real external credentials:
	•	Add a “mock mode” flag (e.g., HERMES_MOCK=1) that:
	•	Mocks API responses for each integration endpoint (GA4, GSC, SERP, Technical, Performance, Competitive, Decay, KBase, Authority, Blog, Orchestrator, Audit, Notifications)
	•	Serves deterministic fixtures so UI can render and actions can succeed
	•	If mock mode is enabled, the backend should return canned JSON quickly.

What the tester must validate
	1.	Route smoke:

	•	Load the app home/dashboard and confirm it renders.
	•	Visit every primary route (integrations, each integration detail page, runs, audit, notifications, help, etc.)
	•	Assert page has a visible heading and no “404”/blank content.

	2.	Click coverage (the important part)

	•	On each route:
	•	Collect all elements with [data-testid] that start with btn-/link-/card-/menu- (or a known prefix list).
	•	For each element:
	•	Click it (with scroll into view).
	•	Assert that one of these happened within a timeout:
	•	URL changed to a known route
	•	A modal/dialog appeared (role=dialog) with content
	•	A network call to /api/* occurred and UI displayed a success or error message (toast/inline)
	•	If none happens → FAIL with the element’s testid and current route.
	•	After the assertion, return to the previous route (or close modal) so the test can continue.

	3.	No console errors

	•	Fail test if severe console errors occur (uncaught exceptions, React errors).
	•	Allow expected warnings only via an allowlist.

Implementation details
A) Install + setup
	•	Add Playwright dependency and install browsers.
	•	Create playwright.config with:
	•	baseURL from env (e.g., http://localhost:3000)
	•	retries=1, trace=on-first-retry, screenshot=only-on-failure, video=retain-on-failure
	•	Add scripts:
	•	“dev” to start app
	•	“test:ui” to start app (or assume already running) then run Playwright

B) Add mock mode
	•	If Hermes has a backend server:
	•	When HERMES_MOCK=1, route /api/* requests to fixture handlers.
	•	Provide fixtures per service under /test/fixtures/*.json.
	•	If Hermes is frontend-only:
	•	Add MSW (Mock Service Worker) in mock mode to intercept /api/*.

C) Write tests
	•	tests/ui/routes.spec.* for route smoke.
	•	tests/ui/clickability.spec.* for click coverage.
	•	Ensure test is deterministic and doesn’t depend on time of day or real data.

D) CI-ready
	•	Ensure command exits non-zero on failure.
	•	Save report to /test-results/ and /playwright-report/.

Deliverables
	•	Playwright configured + scripts added.
	•	Mock mode implemented + fixtures.
	•	Click-coverage test that fails on dead clicks.
	•	README section: “Running UI tests” with exact commands.

Begin by adding data-testid coverage where missing, then implement mock mode, then write the tests.