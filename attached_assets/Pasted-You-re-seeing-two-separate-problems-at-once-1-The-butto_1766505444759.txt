You’re seeing two separate problems at once:

1. The **buttons aren’t actually iterating services** (0 tested / undefined checked = bug in the “which services should run” selection + loop)
2. The **UX/data model doesn’t support async jobs** (some services take 20–30 minutes; you need “started → running → completed” with polling + final outputs)

Also, the “3 missing in table but none missing in inspector” is almost always **table using catalog expected outputs** while inspector is showing a different run type or a different “latest run” query.

Below are **developer instructions** that fix all of this in a clean, production-ready way.

---

# Developer Instructions: Make Test Connections + Smoke Tests Actually Run (Async + Truthful)

## Goal

When user clicks:

* **Test Connections** → checks *all built services* that have worker configs and logs a connection run
* **Run Smoke Tests** → starts *real smoke runs* for all built+ready services; async workers are queued and polled until done

UI must show:

* queued/running/completed counts
* per-service progress
* missing outputs computed from **the latest SMOKE run**, consistent in table and inspector

---

## 1) Fix “0 services tested” / “undefined services checked”

That means the backend is failing to build the services list.

### Root causes to check (likely)

* siteId not passed / null → list becomes empty
* catalog filtering wrong (e.g., category mismatch)
* slug mismatch between UI and catalog map
* using `services.length` from a field that’s undefined

### Required backend behavior

Create a single function used by both buttons:

`getRunnableServices(siteId, mode)`

Where:

* mode = `connection` returns all built services with config requirements
* mode = `smoke` returns built services that are `ready` + `supportsSmoke`

Return an array of objects with:

* `slug`, `displayName`, `integrationType`, `supportsAsync`, `testEndpoints`

If it returns 0, return a **hard error** with debug reasons:

* “0 services found because: siteId missing”
* “0 services found because: no services marked built”
  Do not silently say “0 tested.”

### Add server-side logging

On button press, log:

* siteId
* count services found
* list of slugs found

---

## 2) Introduce a proper async “job runner” for tests

### New table: `test_jobs`

* `id` uuid
* `site_id` uuid
* `job_type` (`connection_all` | `smoke_all` | `smoke_one`)
* `status` (`queued` | `running` | `done` | `failed`)
* `created_at`, `started_at`, `finished_at`
* `summary` text
* `progress_json` jsonb

  * total
  * started
  * completed
  * failed
  * per_service map

### New endpoint behaviors

#### A) Start Connections Test

`POST /api/tests/connections/start { siteId }`

* creates a `test_jobs` record
* enqueues tasks per service
* returns `{ jobId }`

#### B) Start Smoke Test (All)

`POST /api/tests/smoke/start { siteId }`

* creates a `test_jobs` record
* enqueues smoke tasks per service (async safe)
* returns `{ jobId }`

#### C) Poll status

`GET /api/tests/:jobId`

* returns progress + per-service state

UI should poll every 2–5 seconds.

---

## 3) Each service test must create a `service_run` with run_type

You already added run types—use them consistently.

### service_runs.run_type

* `connection`
* `smoke`

### Requirements

* For every service tested:

  * create `service_run` immediately (status=running)
  * update when complete

### For long-running workers (crawler, competitive intel)

Your “smoke test” should **not** run a full 900-page crawl.
It should run a **smoke mode** that finishes fast.

#### Smoke payload standard

Every worker must support:

* `mode: "smoke"`
* `max_urls: 10` (crawler)
* `keywords: 5` (serp)
* `limit: 5` (backlinks)
* `dry_run: true` for content generator if needed

If a worker doesn’t have smoke mode, then it’s not testable at scale.

So implement smoke mode in those workers first.

---

## 4) Add async worker “job_id” propagation + polling

### If worker responds with 202

* Hermes stores `worker_job_id` in `service_runs.metrics_json.jobId`
* Hermes sets status=running
* Hermes’s polling loop checks:

  * `GET worker/status?jobId=...`
* When completed, update `service_run`:

  * status success/partial/failed
  * outputs_json.actualOutputs
  * missingOutputs computed

### If worker responds 200 with result

Update run immediately.

---

## 5) Fix “Missing outputs mismatch” between table and inspector

### Rule: Table and inspector must both use the latest SMOKE run

Right now you likely have:

* table showing missing based on catalog only
* inspector showing missing based on latest run (maybe connection run)

Fix it by enforcing:

* “Missing” column always reads from latest `run_type="smoke"` for that service/site
* Inspector “Missing” section also reads from latest `run_type="smoke"` for that service/site

If no smoke run exists:

* show “Not tested yet” (not “3 missing”)

### Backend helper

`getLatestRuns(siteId, runType)`

* returns latest run per service_slug filtered by runType

---

## 6) Update UI labels and flows

### Buttons should behave like:

* Click Run Smoke Tests
* UI shows:

  * “Smoke Test started: 0/13 completed”
  * per-service status: queued/running/done
  * elapsed time
* When done:

  * “Smoke Test complete: 10 passed, 2 partial, 1 failed”

No more “0 services tested.”

### Service row status should show:

* Connection status (optional)
* Smoke status (primary)
* Missing outputs (only from smoke)

---

## 7) Practical constraints (crawler / long runs)

You said crawl can take 20–30 minutes for full site. That’s a **full run**, not a smoke test.

You need two modes:

### A) Smoke crawl (fast)

* 10–25 URLs max
* homepage + top templates (services/blog/location)
* goal: validate pipeline + output schema

### B) Full crawl (slow)

* 300–900 pages
* scheduled job
* progress tracking

So add another button later:

* “Run Full Crawl” (only for crawler)
* shows progress bar and ETA-ish metrics

But your “Run Smoke Tests” should never start a 30-minute crawl.

---

## 8) Acceptance criteria (your sanity checks)

After implementing:

1. Clicking **Test Connections**

* returns jobId
* UI shows progress (e.g., “13/13 checked”)
* creates connection runs per service

2. Clicking **Run Smoke Tests**

* returns jobId
* UI shows per-service progress
* async workers show running until job completes
* creates smoke runs per service

3. “Missing” on table matches “Missing” in inspector

* both use latest smoke run
* if never smoke tested: “Not tested”

4. Crawler smoke completes in < 2 minutes

* full crawl is separate action

---

## What you can do right now (fast unblock)

Until the async job runner exists, you can still get value by:

* running smoke tests one service at a time (per-row button)
* making that call synchronous for quick checks

But the correct fix is the job runner + polling.

---

If you want, tell me which worker endpoints currently exist for **crawler**, **competitive intel**, and **serp** (start + status), and I’ll write the exact smoke payloads + expected output slugs so the missing outputs become meaningful immediately.
