Replit Prompt: Speed Up Integrations Page — Cache Results + Stale-While-Revalidate (Instant UI, Background Refresh)

Problem
Integrations page has a long delay before anything loads. The UI waits on live health checks / worker calls before rendering, which makes the page feel slow and unreliable.

Goal
Make Integrations load instantly by using cached results (last known good), then refresh in the background (“stale-while-revalidate”) to update statuses.

Requirements

* The page should render immediately with:

  * last known statuses
  * last run timestamps
  * cached metrics sample counts
* Background refresh updates the UI when new results arrive.
* If refresh fails, keep cached results visible and show a small “Couldn’t refresh (showing last known)” indicator.
* Do not require users to manually refresh just to see something.

Implementation plan

1. Add a server-side cache layer for Integrations summary
   Create a single endpoint:
   GET /api/integrations/summary?siteId=...

Behavior:

* Return cached summary instantly from DB (or memory cache) with a `cachedAt` timestamp.
* Trigger a background refresh job if cache is stale (or if client requests refresh=true).

Return shape:
{
siteId,
cachedAt,
isStale: true/false,
summary: {...},
services: [...],
nextActions: [...],
lastRefreshAttempt: {...},
lastRefreshError: {...}
}

2. Persist “last known” integration state in DB
   Add a table:
   integration_status_cache(
   site_id,
   payload_json,
   cached_at,
   computed_from_run_id,
   last_refresh_status,
   last_refresh_error
   )

Populate it from:

* last diagnostics run
* last smoke test run
* last service health checks
  This is what the UI reads first.

3. Implement background refresh (SWR)
   When /api/integrations/summary is called:

* If cached_at is recent (e.g., < 60s): return cache only.
* If stale (>= 60s or configurable):

  * return cached immediately with isStale=true
  * start an async refresh:

    * ping services/workers (with warm-up + retry)
    * recompute statuses + next actions
    * write updated payload back to integration_status_cache

If async tasks aren’t feasible in-process, do a “fire-and-forget” refresh via:

* a lightweight internal job runner
* or a queue table processed by the orchestrator
  But the key is: do NOT block the response.

4. Client-side rendering rules
   On Integrations page load:

* Render from cached payload immediately.
* If isStale=true:

  * show subtle indicator: “Updating…”
  * poll once after a short delay (e.g., 1–2s) or subscribe to SSE if available:
    GET /api/integrations/summary?siteId=...&preferFresh=true
* If new cachedAt is newer, update UI state.

Add a manual Refresh button that forces a refresh:

* /api/integrations/refresh?siteId=...
  but the default should feel instant even without clicking Refresh.

5. Warm-up + retry baked into refresh
   Use the same cold-start resilience:

* warm-up ping with short timeout
* retry on 502/503/timeout
* only then run real checks
  Store error types so we can distinguish “sleeping” from “misconfigured”.

6. Cache TTLs and invalidation

* Short TTL for health status: 60–120s
* Longer TTL for stable info (expected inputs/outputs, service definitions): 24h
* Invalidate/refresh cache when:

  * secrets/config change for the site
  * user clicks “Run QA” / “Run Smoke Tests”
  * a diagnostics run completes

Acceptance criteria

* Integrations page shows content immediately (no blank waiting screen).
* Background refresh updates statuses within a couple seconds.
* If refresh fails, page still shows last known data + “showing cached results” message.
* Manual refresh still works but is no longer required for usability.

Deliverables

* integration_status_cache storage
* /api/integrations/summary with SWR behavior
* background refresh job + warm-up retry
* UI updated to render cached instantly + update when fresh results arrive
