Replit Prompt: Wire “Socrates” (Knowledge Base Worker) into the Lineage System + Enable Read/Write Flywheel (Learnings In, Guidance Out)

Context
We just added read-write capability to the Knowledge Base Worker. In the UI, the Knowledge Base Worker is named “Socrates”. We need to tie the naming and data lineage together so the platform uses Socrates correctly as:

1. A sink for learnings (apps write to it)
2. A source for decision-making (apps read from it before acting)
   This enables a flywheel / self-learning system.

Goals
A) Naming lineage: “Socrates” (crew) must map to the Knowledge Base Worker (service) everywhere.
B) Data lineage: Create a clear contract for what gets written to the KB and how it’s queried.
C) Runtime behavior: Any decision/action (missions, fix PRs, recommendations) must consult Socrates first.

Part 1 — Canonical mapping (registry)

1. Add Socrates to the shared registry (single source of truth)
   In shared/registry.ts define:

* crewId: "socrates"
* crewDisplayName: "Socrates"
* serviceId: "knowledge_base"
* serviceDisplayName: "Knowledge Base Worker"
* description: “Stores learnings and returns guidance for future decisions”
* capabilities:

  * write: true
  * read: true
* ownedMetrics/outputs:

  * kb.insights_written_count
  * kb.guidance_used_count
  * kb.last_sync_at

2. Apply the naming rule across UI

* In Integrations list: show “Socrates” as primary, “Knowledge Base Worker” as secondary.
* In modals: same.
* Anywhere “Knowledge Base” appears without “Socrates”, fix it to match the naming convention.

Part 2 — Define the Knowledge Base data contract (what is stored)
3) Create a normalized schema for KB entries
We need a consistent “learning record” format so any worker can write and any decision engine can read.

Recommended KB entry structure:
KBEntry = {
id,
siteId,
sourceCrewId,         // who produced the learning (Speedster/Popular/etc.)
sourceServiceId,
type,                 // "observation" | "recommendation" | "fix_result" | "experiment" | "incident"
topic,                // "core_web_vitals" | "indexing" | "content_strategy" | "ads" | "schema" etc.
title,
summary,
evidence: {
metrics: {...},     // canonical metric keys
urls: [...],
queries: [...],
screenshots?: [...],
runIds?: [...]
},
decision: {
proposedAction?: {...},
executedAction?: {...},   // what we actually did (if any)
prUrl?: "...",
changeSetId?: "...",
},
outcome: {
status: "pending" | "succeeded" | "failed" | "reverted",
notes?: "...",
measuredImpact?: {...}    // before/after metrics
},
tags: [...],
createdAt,
updatedAt
}

4. Create “site memory” namespaces
   All KB operations should be scoped by siteId. Within a site:

* “playbooks” (stable guidance)
* “history” (past actions/outcomes)
* “evidence” (structured facts and snapshots)

Part 3 — Implement Socrates APIs (read + write)
5) Add two endpoints in Hermes that proxy to Socrates consistently
Write:
POST /api/kb/write
Body: { siteId, entry: KBEntry }

* Validates schema
* Attaches runId/requestId
* Sends to Socrates write endpoint using READ/WRITE keys

Read:
POST /api/kb/query
Body: { siteId, query, filters, limit }

* Sends to Socrates read endpoint
* Returns relevant entries + summaries

Important:

* Hermes should be the single integration point for other workers/pages, so UI/services don’t call Socrates directly.
* Hermes handles auth keys and consistent request shape.

Part 4 — Enforce “Consult Socrates first” in decision-making
6) Add a “KB preflight” step in every decision pipeline
Before generating:

* missions
* recommendations
* export fix packs
* “Fix It / Create PR”
  Do:
  A) Query Socrates for:
* similar past issues (same topic + similar metrics)
* past actions taken and outcomes
* known best practices/playbooks for this topic/site
  B) Use the response to:
* avoid repeating failed fixes
* prefer previously successful fixes
* tailor recommendations to the site’s history

7. Write back outcomes to Socrates automatically
   After a run completes:

* If a mission is generated: write a KB entry “recommendation” with evidence + rule
* If a PR is created: write a KB entry “executedAction” with PR URL + change summary
* If results are measured later (e.g., after 7 days): write an “outcome” update

Part 5 — UI integration (make the flywheel visible)
8) Add a “Socrates Memory” section in Mission Control or Settings
Show:

* last KB write time
* last KB query time
* recent learnings (last 5)
* “used in recommendations: yes/no” indicator

9. Add provenance in mission details
   In every mission detail view:

* “Consulted Socrates” badge
* “Relevant prior learnings” list (2–3 items)
  So we can trust recommendations are grounded.

Acceptance criteria

* Socrates crew name and Knowledge Base Worker name are consistently mapped everywhere (no mismatched naming).
* Any worker can write learnings to Socrates via Hermes and they are stored per site.
* Any decision pipeline queries Socrates first and uses history to influence output.
* Outcomes (PRs, fixes, failures) are written back automatically to build the flywheel.
* UI exposes the KB freshness and recent learnings so we can QA that it’s actually working.

Do this now (order)

1. Registry mapping + naming fixes (Socrates ↔ Knowledge Base Worker)
2. Hermes proxy endpoints (/api/kb/write, /api/kb/query)
3. Add KB preflight + post-run writeback in diagnostics + Fix PR pipeline
4. Add UI “Socrates Memory” panel + “Consulted Socrates” mission provenance
