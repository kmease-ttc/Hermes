Implement “No Dead Ends” empty states + remediation prompts across the entire Hermes SEO UI and API.

Goal
Whenever any page/widget/metric/table/chart cannot load real data (missing integration, missing config, missing permissions, empty dataset, not implemented, upstream error, etc.), the UI must show a clear “next action” prompt instead of a blank area, spinner forever, or generic error. Every “no data” state must tell Kevin what to do and provide a clickable CTA.

Core concept: DataStatus + RemediationActions

1. Standardize API responses to include status metadata when data is missing or partial.

* Add a shared type used by all crews/pages, e.g.:

  * status: "ok" | "empty" | "needs_setup" | "needs_config" | "needs_permissions" | "integration_down" | "not_implemented" | "error"
  * reason_code: string (stable enum-ish)
  * user_message: string (short, friendly)
  * developer_message: string (more detail for logs)
  * missing_fields: string[] (optional)
  * required_integrations: string[] (optional)
  * actions: Array<{ id, label, kind, href?, route?, modal?, payload?, priority }>
  * last_success_at, last_attempt_at (optional)

2. UI renders a consistent Empty/Error card for any non-"ok" status, driven by actions[].

UI patterns
Create a reusable component (e.g., <NoDeadEndsState />) that supports:

* Title (e.g., “Connect Google Analytics to see Organic Traffic”)
* Short explanation (user_message)
* Primary CTA (highest priority action)
* Secondary actions (e.g., “Open Settings”, “Test Connection”, “Add API Key”, “Grant Permission”, “View Logs”, “Retry”, “Learn More”)
* “Why am I seeing this?” expandable section (reason_code + developer_message in dev mode)
* Optional inline form inputs when missing_fields are known (e.g., GA4_PROPERTY_ID, GSC_SITE)
* If action is “not implemented”, show “Create task” CTA that pre-fills a ticket/task entry in the app’s internal task/audit log.

Where to apply (must be exhaustive)

* KPI cards: if value missing -> show inline empty state (not “0” unless truly zero).
* Charts: if no series -> show empty state with CTA (connect/fix).
* Tables (drops/missions/root causes/etc.): if empty due to missing data -> show empty state; if truly empty dataset -> show “No findings yet” + “Run scan” CTA.
* Integrations page: each integration card shows status and next action; never just “Not configured” without CTA.
* Settings/config pages: if required env/config missing -> show inline prompts and “Save” action.
* Any page route where backend is not wired -> show “This module isn’t wired yet” + “Implement now” CTA (links to internal dev checklist and/or opens a modal with the exact missing endpoints/config).

Action types to support

* route: navigate to internal route (/settings/integrations, /settings/env, /crew/<name>/setup)
* href: open external OAuth/permission URL
* modal: open modal for inline config (API keys, site URL, property ID, etc.)
* retry: re-run fetch
* test_connection: calls /api/integrations/<x>/test then updates UI
* run_scan: triggers job and shows progress
* view_logs: opens logs panel filtered to this widget/page
* create_task: logs a dev task with context (crew, widget, reason_code, stack, missing_fields)

Backend requirements

* For every existing endpoint used by the UI, wrap data in a standard envelope:

  * { data, meta: { status, reason_code, actions, ... } }
* Ensure “empty but ok” is distinguishable from “empty because missing setup”.

  * Example: “No drops detected” (ok + empty dataset) vs “Can’t detect drops: GA4 not connected” (needs_setup).
* Add integration health endpoints (or expand existing) to report:

  * connected: boolean
  * last_ok_at
  * last_error
  * missing_scopes
  * missing_env_vars
  * required_next_steps -> actions[]
* Add a small “capabilities” map per crew so UI can show “not implemented” states intentionally:

  * capabilities: { kpis: true, drops: false, rootCauses: true, ... }
  * Any false capability must yield status: "not_implemented" + create_task action.

Global UX rules

* No silent failures. If fetch fails, show error state with Retry + View Logs + (if likely) Fix Setup CTA.
* No infinite spinners. After a timeout (e.g., 8–12s), show state card: “Still working…” with Retry and View Logs.
* Prefer “Actionable defaults”: if you can infer which setting is missing, present the exact field and allow save inline.
* Always include at least one primary CTA unless status is “ok + empty dataset” (then primary CTA is “Run scan” or “Refresh data”).

Implementation checklist

1. Add shared types for MetaStatus and RemediationAction in shared/ (both server + client).
2. Build client component library:

   * NoDeadEndsState (full)
   * InlineKpiEmpty (compact for KPI tiles)
   * ChartEmptyState
   * TableEmptyState
3. Add a “Settings deep link router” so actions can jump to the right section and highlight missing fields.
4. Update each crew page to:

   * interpret meta.status
   * render state components
   * never render blank widgets
5. Add integration test action handlers:

   * “Test connection” button triggers endpoint and surfaces results
6. Add an “Audit/Task log” entry when user clicks “Create task” or “Implement now”.
7. Add a dev-only “Simulate missing data” toggle to verify empty states quickly.
8. Add E2E smoke checks: navigate all pages and assert no “empty container” placeholders; every widget shows either real content or NoDeadEndsState with at least one CTA.

Acceptance criteria (strict)

* On every page, every widget area is always in one of: loaded content OR actionable state card.
* If any required input is missing, the UI shows the exact input name and a path to set it.
* For each missing-data scenario, there is at least one CTA that directly helps Kevin fix it (config, connect, permission, run job, view logs, create task).
* No dead-end message like “Not configured” without a CTA.
* Works consistently across Natasha, Lookout, Popular, Scotty, Speedster, Sentinel, Hemingway, Beacon, Atlas, Draper, Socrates (and any future crews).

Start by implementing this pattern on one representative page (e.g., Atlas or Hemingway), then roll it out across all crews using the shared components and the standardized API meta envelope.
