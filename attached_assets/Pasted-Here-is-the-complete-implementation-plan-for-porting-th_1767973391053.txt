Here is the complete implementation plan for porting the Website Generator feature:

Website Generator Port: Project A → Project B Implementation Plan
A. Quick Summary
Entry Point: /tools/website-generator route renders Start.tsx (2-step wizard for business info + branding)
API Endpoint: POST /api/intake creates a site record and queues a generate_preview_site job
Worker: Polls jobs table, processes generate_preview_site jobs → generates content → builds static HTML → publishes to object storage
Storage: PostgreSQL for data (sites, jobs, siteAssets) + Google Cloud Storage for published HTML files
Key Shared Modules: contentGenerator.ts, siteBuilder.ts, sitePublisher.ts, instantLogo.ts, stockImageService.ts
Output: Static HTML site published to /public-objects/sites/{siteId}/index.html
Time to Preview: ~30-60 seconds (fast path with stock images + instant logo)
B. Feature Map (User Flow)
1. User visits /tools/website-generator
   ↓
2. Step 1: Enter business info (name, type, city, email, phone, description)
   ↓
3. Step 2: Select style preference, optional logo/hero upload
   ↓
4. Submit → POST /api/intake
   ↓
5. Backend:
   a) Insert row into `sites` table (status=preview_pending)
   b) Upload user images to object storage (if provided)
   c) Insert job into `jobs` table (type=generate_preview_site)
   d) Return { siteId, previewToken }
   ↓
6. User redirected to preview page (polls for status)
   ↓
7. Worker picks up job:
   a) Classify industry
   b) Select stock hero image (or use user-uploaded)
   c) Generate instant logo (or use user-uploaded)
   d) Extract content from existing website (if provided)
   e) Call OpenAI to generate website content
   f) Build static HTML bundle (4 pages: home, about, services, contact)
   g) Publish to object storage
   h) Update site.status = preview_ready, site.previewUrl
   ↓
8. Preview page shows iframe with generated site
   ↓
9. User enters email → Magic link sent → Account created → Site claimed
C. Source Inventory (Project A)
UI Files (client/src/pages)
File	Purpose	Dependencies
Start.tsx	Main 2-step wizard form	@/components/ui/*, useMutation, useLocation
WebsiteGenerator.tsx	Wrapper with SEO meta tags	Start.tsx, PageSEO
Server Files (server/)
File	Purpose	Key Functions
routes.ts	API endpoints	/api/intake, /api/upload-image, /api/generate-description, /api/sites/:id/public, /api/sites/:id/status
worker.ts	Background job processor	processGeneratePreviewSite(), processUpgradeSiteAssets(), job polling loop
objectStorage.ts	Object storage wrapper	ObjectStorageService, upload/download functions
Shared Modules (shared/)
File	Purpose	Exports
schema.ts	Database schema	sites, jobs, siteAssets, arcloUsers, types
contentGenerator.ts	AI content generation	generateWebsiteContent()
siteBuilder.ts	Static HTML builder	buildStaticSiteBundle()
sitePublisher.ts	Publish to GCS	publishSiteBundle(), uploadGeneratedImage()
instantLogo.ts	Monogram logo generator	generateInstantLogo(), uploadInstantLogoToStorage()
stockImageService.ts	Stock image selection	selectHeroImage()
themes.ts	Color themes	getRecommendedTheme(), siteThemes
styleClusters.ts	Style variations	StyleCluster type
contentCrawler.ts	Extract from existing site	extractBusinessContent()
D. Target Integration Plan (Project B)
New Files to Create
client/src/pages/WebsiteGenerator.tsx     ← Copy from Project A
client/src/pages/Start.tsx                ← Copy from Project A
client/src/pages/SitePreview.tsx          ← Create for preview polling
server/worker.ts                          ← Copy core job processing logic
server/objectStorage.ts                   ← Copy if not exists
shared/contentGenerator.ts                ← Copy
shared/siteBuilder.ts                     ← Copy
shared/sitePublisher.ts                   ← Copy
shared/instantLogo.ts                     ← Copy
shared/stockImageService.ts               ← Copy
shared/themes.ts                          ← Copy
shared/styleClusters.ts                   ← Copy
shared/contentCrawler.ts                  ← Copy
Files to Modify
client/src/App.tsx                        ← Add routes for /tools/website-generator, /preview/:id
server/routes.ts                          ← Add /api/intake, /api/upload-image, /api/sites/* endpoints
server/index.ts                           ← Import and start worker
shared/schema.ts                          ← Add sites, jobs, siteAssets tables
E. Data Model + Migrations
Table: sites
export const sites = pgTable("sites", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  businessName: text("business_name").notNull(),
  city: text("city"),
  niche: text("niche"),
  phone: text("phone"),
  contactEmail: text("contact_email"),
  existingWebsite: text("existing_website"),
  status: text("status").notNull().default("preview_pending"),
  buildState: text("build_state").notNull().default("pending"),
  previewUrl: text("preview_url"),
  heroImageUrl: text("hero_image_url"),
  logoUrl: text("logo_url"),
  userProvidedLogo: boolean("user_provided_logo").default(false),
  userProvidedHero: boolean("user_provided_hero").default(false),
  heroImageStatus: text("hero_image_status").default("pending"),
  previewToken: text("preview_token"),
  configVersion: integer("config_version").default(1),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});
Table: jobs
export const jobs = pgTable("jobs", {
  id: serial("id").primaryKey(),
  type: text("type").notNull(),
  payloadJson: text("payload_json").notNull(),
  status: text("status").notNull().default("queued"),
  progress: integer("progress").default(0),
  progressMessage: text("progress_message"),
  errorMessage: text("error_message"),
  attempts: integer("attempts").default(0),
  runAfter: timestamp("run_after").notNull().defaultNow(),
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
Table: site_assets
export const siteAssets = pgTable("site_assets", {
  id: serial("id").primaryKey(),
  siteId: integer("site_id").references(() => sites.id).notNull(),
  assetType: text("asset_type").notNull(),
  source: text("source").notNull(),
  sourceAssetId: text("source_asset_id").notNull(),
  urlOriginal: text("url_original").notNull(),
  urlCached: text("url_cached"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});
Migration Command
npm run db:push
F. API Contract
POST /api/intake
Request:

{
  "email": "user@example.com",
  "businessName": "Joe's Plumbing",
  "city": "Austin, TX",
  "niche": "Plumbing",
  "website": "https://existing-site.com",
  "phone": "555-123-4567",
  "logoUrl": "https://storage.../logo.png",
  "heroImageUrl": "https://storage.../hero.png"
}
Response:

{
  "ok": true,
  "siteId": 123,
  "previewToken": "abc123..."
}
POST /api/upload-image
Request:

{
  "imageBase64": "data:image/png;base64,...",
  "filename": "logo.png",
  "type": "logo" | "hero" | "gallery"
}
Response:

{ "url": "https://storage.../images/logo.png" }
GET /api/sites/:id/public?token=xxx
Response:

{
  "id": 123,
  "businessName": "Joe's Plumbing",
  "status": "preview_ready",
  "buildState": "draft_ready",
  "previewUrl": "https://app.../public-objects/sites/123/index.html",
  "heroImageUrl": "...",
  "logoUrl": "..."
}
GET /api/sites/:id/status
Response:

{
  "status": "preview_ready",
  "buildState": "draft_ready",
  "heroImageStatus": "ready",
  "previewUrl": "..."
}
G. UI Tab & UX Wiring
Route Registration (App.tsx)
<Route path="/tools/website-generator" component={WebsiteGenerator} />
<Route path="/preview/:siteId" component={SitePreview} />
Navigation Placement
Add link in existing Tools page or main navigation:

<Link href="/tools/website-generator">
  Free Website Generator
</Link>
State Management
useMutation for form submission
useQuery for preview status polling
Local state for form steps
H. Job Orchestration
Worker Loop (server/worker.ts)
const POLL_INTERVAL = 5000; // 5 seconds
const MAX_RETRIES = 3;
async function processJob() {
  const job = await db.query.jobs.findFirst({
    where: and(
      eq(jobs.status, "queued"),
      lte(jobs.runAfter, new Date())
    ),
  });
  if (!job) return;
  // Set to running
  await db.update(jobs).set({ status: "running", startedAt: new Date() });
  try {
    if (job.type === "generate_preview_site") {
      await processGeneratePreviewSite(job);
    }
    await db.update(jobs).set({ status: "done", completedAt: new Date() });
  } catch (error) {
    const attempts = (job.attempts || 0) + 1;
    if (attempts < MAX_RETRIES) {
      // Exponential backoff retry
      await db.update(jobs).set({
        status: "queued",
        runAfter: new Date(Date.now() + 60000 * attempts)
      });
    } else {
      await db.update(jobs).set({ status: "failed", errorMessage: error.message });
    }
  }
}
setInterval(processJob, POLL_INTERVAL);
Job Types
generate_preview_site - Main site generation (fast path)
upgrade_site_assets - Background AI image generation (optional)
I. Templates/Assets/Storage
Object Storage Structure
/{bucketId}/public/
  └── sites/
      └── {siteId}/
          ├── index.html      (home page)
          ├── about.html
          ├── services.html
          ├── contact.html
          └── images/
              ├── logo.png
              └── hero.jpg
/{bucketId}/.private/
  └── uploads/
      └── {uuid}/
          └── {filename}
Environment Variables
DEFAULT_OBJECT_STORAGE_BUCKET_ID=xxx
PUBLIC_OBJECT_SEARCH_PATHS=/bucketId/public
PRIVATE_OBJECT_DIR=/bucketId/.private
Static Route (server/routes.ts)
app.get("/public-objects/*", async (req, res) => {
  const filePath = req.params[0];
  const file = await objectStorage.searchPublicObject(filePath);
  if (!file) return res.status(404).send("Not found");
  await objectStorage.downloadObject(file, res);
});
J. Security/Abuse Controls
Secrets Required
AI_INTEGRATIONS_OPENAI_API_KEY    # For content generation
AI_INTEGRATIONS_OPENAI_BASE_URL   # OpenAI base URL
DEFAULT_OBJECT_STORAGE_BUCKET_ID  # GCS bucket
PUBLIC_OBJECT_SEARCH_PATHS        # Public file paths
PRIVATE_OBJECT_DIR                # Private uploads
Rate Limiting
Limit /api/intake to 5 requests per IP per hour
Limit /api/upload-image to 10 uploads per session
Max file size: 10MB
Access Control
Preview sites accessible via previewToken query param
Only site owner can claim/publish site
Admin access for site management
K. Testing & QA
Unit Tests
 contentGenerator.ts - Mock OpenAI, verify output structure
 siteBuilder.ts - Verify HTML generation for each page
 instantLogo.ts - Test SVG generation
Integration Tests
 /api/intake creates site + job
 Worker processes job and publishes site
 /api/sites/:id/public returns correct data
E2E Test Plan (Playwright)
1. Navigate to /tools/website-generator
2. Fill in business name, type, city, email
3. Click Continue
4. Select style preference
5. Click Generate Website
6. Verify redirect to preview page
7. Wait for site generation (poll status)
8. Verify preview iframe loads
9. Verify generated site has correct business name
Manual QA Checklist
 2-step form validation works
 Logo upload works
 Hero image upload works
 AI description generation works
 Progress updates show during generation
 Preview loads in under 60 seconds
 Generated site is mobile-responsive
 Contact info displays correctly
L. Cutover & Rollout
Phase 1: Internal Testing
Deploy behind feature flag: ENABLE_WEBSITE_GENERATOR=false
Test with internal team
Fix any bugs
Phase 2: Beta
Enable for specific users via allowlist
Gather feedback
Monitor error rates and generation times
Phase 3: GA
Set ENABLE_WEBSITE_GENERATOR=true
Add to public navigation
Monitor usage metrics
M. Assumptions + How to Verify (in Project A)
Assumption	Verify In
OpenAI model is gpt-4o	shared/contentGenerator.ts line ~200
Worker polls every 5 seconds	server/worker.ts - POLL_INTERVAL
Max 3 retries per job	server/worker.ts - MAX_RETRIES
Sites table has all required fields	shared/schema.ts - sites definition
Object storage uses GCS	server/objectStorage.ts, shared/sitePublisher.ts
Static files served at /public-objects/*	server/routes.ts
Ripgrep Commands to Verify
# Find intake endpoint
rg "api/intake" server/
# Find job types
rg "job.type ===" server/worker.ts
# Find content generator call
rg "generateWebsiteContent" server/
# Find publish function
rg "publishSiteBundle" shared/
This plan provides everything needed to port the Website Generator feature to Project B. Start with schema migrations, then copy shared modules, then wire up routes and worker, and finally add the UI.