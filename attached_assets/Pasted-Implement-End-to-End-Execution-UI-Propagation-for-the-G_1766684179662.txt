Implement **End-to-End Execution + UI Propagation** for the Google Data Connector (Worker Mode)

Context:

* Google Data Connector (worker mode) is now fully connected.
* Smoke tests pass.
* All 9 outputs are validated.
* Next step: actually **run the connector**, persist real findings, and ensure results appear correctly across all UI tabs (Dashboard, Analysis, Web Authority, Suggested Changes, etc.).

Goal:
When the Google Data Connector runs (manually or scheduled), its **real data** must:

1. Be executed via the worker
2. Be persisted in the database
3. Be normalized into Hermes’ internal data model
4. Immediately surface in the correct UI tabs
5. Be explainable and traceable back to the run that produced it

---

## 1) Execution: How the connector should be run

### Trigger types

The Google Data Connector must support:

* Manual run (button click)
* Scheduled run (cron / background job)
* Dependency run (e.g. before Web Authority, Analysis, or Suggestions)

### Execution contract

Hermes must call the worker using:

POST `{base_url}/run`

Request payload:
{
"site_id": "<internal site id>",
"domain": "example.com",
"requested_outputs": [
"gsc_impressions",
"gsc_clicks",
"gsc_ctr",
"gsc_position",
"gsc_queries",
"gsc_pages",
"ga4_sessions",
"ga4_users",
"ga4_conversions"
],
"request_id": "<uuid>"
}

Headers:

* x-api-key
* Authorization: Bearer
* X-Request-Id

---

## 2) Persistence: Where results must be stored

After a successful run, Hermes must persist **one canonical run record**:

Table: `integration_runs` (or equivalent)

Required fields:

* integration_id = google_data_connector
* site_id
* run_id / request_id
* status = success | partial | failed
* started_at / completed_at
* received_outputs (array)
* missing_outputs (array)
* raw_payload (JSON, stored but not rendered directly)
* normalized_payload (JSON)

This run record becomes the **source of truth** for all downstream features.

---

## 3) Normalization: Map worker output → Hermes data model

Normalize the worker response into Hermes’ internal schema:

### Traffic / Analytics

* ga4_sessions → traffic.sessions
* ga4_users → traffic.users
* ga4_conversions → traffic.conversions

### Search Performance

* gsc_impressions → search.impressions
* gsc_clicks → search.clicks
* gsc_ctr → search.ctr
* gsc_position → search.avg_position

### Content Intelligence

* gsc_queries → search.top_queries[]
* gsc_pages → search.top_pages[]

Store normalized values in:

* `site_metrics_daily`
* `site_metrics_current`
* `search_queries`
* `search_pages`
  (or equivalent tables)

---

## 4) UI Propagation: Where the data must appear

### Dashboard

* Website Traffic card:

  * Sessions
  * Users
  * Conversions
* “Last updated” timestamp must reflect the connector run

### Analysis tab

* Traffic trends (GA4-based)
* Search visibility trends (GSC-based)
* Correlate with connector run time

### Web Authority tab

* Use GSC impressions, clicks, and position as ranking inputs
* Authority score recalculated after successful run

### Suggested Changes tab

* Use:

  * Low CTR queries
  * High impressions / low clicks pages
* Generate suggestions based on fresh data

### Integrations tab

* Show:

  * Last run status = success
  * 0 missing outputs
  * Last run timestamp
  * Link to run diagnostics

---

## 5) Cache invalidation (critical)

After a successful run:

* Invalidate:

  * Dashboard data cache
  * Analysis cache
  * Web Authority cache
  * Suggestions cache
* Force re-fetch on next UI render

Do NOT rely on page reloads.

---

## 6) Diagnostics & Traceability

Every UI surface must be traceable back to:

* integration_id
* run_id
* timestamp

Add “View Source Run” or “Data from: Google Data Connector – <timestamp>” to:

* Dashboard cards
* Analysis charts
* Suggestions

This prevents future “where did this number come from?” debugging.

---

## 7) Failure handling (non-blocking)

If a run:

* Partially succeeds (e.g. GA4 works, GSC rate-limited):

  * Persist partial data
  * Mark missing outputs
  * Surface warning badge, not total failure

If a run fails:

* Do not overwrite last successful data
* Show stale-data warning in UI

---

## 8) Acceptance Criteria

* Running Google Data Connector populates real data in all relevant tabs
* Integrations list shows 0 missing after run
* Dashboard numbers change based on real GA4/GSC data
* Suggested Changes are generated from fresh inputs
* No screenshots or external tools required to verify correctness

---

Outcome:
Hermes moves from “connector health checker” → **single source of truth for analytics, search performance, and diagnostics**, eliminating GA4/GSC tab-hopping entirely.
