You’re almost certainly right: this looks like a **naming / wiring mismatch**, not an actually-unconfigured integration.

In your screenshot, the Socrates page is explicitly telling you to set `SEO_KBASE_SECRET`, but in Replit Secrets you have `SEO_KBASE_API_KEY` and `SEO_KBASE_WRITE_KEY` (and no `SEO_KBASE_SECRET`). That’s why **Integrations can be “working”** (because it’s using the API key you *do* have), while **the Socrates page still thinks it’s unconfigured** (because it’s checking for a different env var name).

### Fastest confirmation (and immediate workaround)

1. In Replit Secrets, add a new secret:

* Key: `SEO_KBASE_SECRET`
* Value: **copy the exact value from** `SEO_KBASE_API_KEY`

2. Refresh the app and revisit Socrates page.

* If the “needs configuration” banner disappears, you’ve confirmed it was purely a key-name mismatch.

That fixes it without code changes. But the better long-term fix is to make the code consistent (or support aliases).

### What Socrates should “return” (so UI can reliably decide configured vs not)

Right now, your UI is making a binary decision (“configured” vs “not configured”). Make it explicit with a tiny health endpoint (or existing worker call) that returns a stable shape like:

* `configured`: boolean (do we have required keys?)
* `canRead`: boolean (read test passed)
* `canWrite`: boolean (write test passed, if write key exists)
* `baseUrl`: string (sanitized)
* `lastError`: string | null (sanitized)
* `timestamp`: ISO string

Example (shape, not exact code):

```json
{
  "ok": true,
  "configured": true,
  "canRead": true,
  "canWrite": true,
  "baseUrl": "https://<kbase-service>/api",
  "lastError": null,
  "timestamp": "2025-12-31T16:12:00.000Z"
}
```

Then the Socrates page should rely on this, not on a single env var name.

### Replit implementation prompt (do this now)

You are a senior full-stack engineer working in this Replit repo.

Bug:
On the Socrates (Knowledge Base) crew page, the UI says it needs configuration and instructs the user to add SEO_KBASE_SECRET. But the Integrations page shows the Knowledge Base integration working and the Replit Secrets include SEO_KBASE_API_KEY and SEO_KBASE_WRITE_KEY (not SEO_KBASE_SECRET). This indicates an env var name mismatch between the Socrates page/config check and the integration client.

Goal:
Make Socrates “configured/not configured” status consistent everywhere by using the same env keys and/or supporting aliases, and by basing the UI on a canonical health/status response.

Tasks:

1. Find all references to SEO_KBASE_SECRET in the codebase (client + server).

   * Determine whether the Knowledge Base integration actually expects SEO_KBASE_API_KEY and SEO_KBASE_WRITE_KEY.
   * Identify where the Socrates page decides “not configured”.

2. Fix naming mismatch:

   * Preferred: standardize to SEO_KBASE_API_KEY (and SEO_KBASE_WRITE_KEY when write is needed).
   * Backwards-compatible: support aliasing so SEO_KBASE_SECRET is accepted as a fallback for SEO_KBASE_API_KEY.
   * Never log secret values.

3. Add a canonical status endpoint for the Knowledge Base integration (server-side), e.g. GET /api/integrations/kbase/status (or similar existing route pattern):

   * Returns a stable JSON shape:
     {
     ok: boolean,
     configured: boolean,
     canRead: boolean,
     canWrite: boolean,
     baseUrl: string | null,
     lastError: string | null,
     timestamp: string
     }
   * configured is true when required keys exist (API key at minimum; write key if write features are enabled).
   * canRead/canWrite perform minimal lightweight checks with short timeouts and no side effects.

4. Update the Socrates crew page to use this status endpoint for:

   * Displaying the “needs configuration” banner
   * Showing “configured” state
   * Showing a degraded state with a useful error when configured=true but canRead/canWrite=false

5. Ensure Integrations page and Socrates page use the same underlying configuration logic (same keys, same status object).

Acceptance criteria:

* If SEO_KBASE_API_KEY exists, Socrates no longer says “needs configuration”.
* If keys exist but the worker fails, UI shows “Configured but failing” with lastError and a clear “View diagnostics / retry” affordance.
* No pages hard-fail; they render even when the integration is down.

Deliver:

* Code changes with minimal scope
* Short note in console/logs: “KBase status: configured=..., canRead=..., canWrite=...”

If you want the **quickest no-code fix**, add `SEO_KBASE_SECRET` as an alias for `SEO_KBASE_API_KEY` in Replit Secrets. If you want the **correct fix**, run the prompt above so the UI never depends on a single magic env var name again.
